No início do projeto, já existia um desenvolvimento em andamento em relação ao SLAM. Entretanto este enfrentava sérios problemas. Os maiores deles eram relativos à localização do rôbo no ambiente e limitações no sensor (Kinect) que não detecta obstáculos próximos (só os detecta em torno de 80 cm). Sendo assim, nossa primeira abordagem buscou resolver o problema de detecção de obstáculos próximos. Não só isso, mas a utilização do \textit{Nuvem de Pontos} do Kinect era limitada por um dos pacotes utilizados, o \verb|gmapping|, que só trabalha com vetores de distância \cite{G_mapping}. Esta conversão causava uma série de perdas de informação, de maneira que a representação virtual do ambiente não condizia com a realidade. 

A proposta inicial foi a adição de um sonar, buscando melhorar a representação virtual do ambiente e tornar menos relevante a limitação do Kinect. Acreditamos, inicialmente, que deveríamos simplesmente adicionar esta fonte de dados ao \verb|gmapping|, configurando este para ter duas fontes de dados, só que descobrimos que isso não é possível, já que o pacote gmapping aceita somente uma. Sendo assim, surgiu a necessidade de fundir os dados do Kinect com os dados do sonar, de maneira que as informações fornecidas ao pacote fossem provenientes só de uma fonte. Inicialmente, queríamos escrever um nó do ROS para fazer esta fusão de dados, mas isto tornou-se muito complexo. Então, buscamos um pacote que ajudasse a fazer esta fusão, encontrando o pacote \verb|ira_laser_tools| que permitiu a fusão e possibilitou a virtualização de scanners a laser. A virtualização faz com que o ROS enxergue várias fontes de dados a partir de uma, no nosso caso uma \textit{Nuvem de Pontos}, sendo estas fontes posicionadas em relação a fonte original, possibilitando a fusão de vários vetores de distância em um só, mais representativo do ambiente. Mais informações podem ser encontradas em \cite{iraLaserTools}.

Utilizando-se deste pacote, a representação do ambiente tornou-se muito mais fiel, detectando uma maior variedade de obstáculos, de maneira que os dados do gmapping se aproximaram da \textit{Nuvem de Pontos}. Essa coerência entre os dados melhorou o funcionamento do sistema de localização.

Nesta etapa, o robô começou a detectar obstáculos onde não existiam. Um dos problemas foi como a equipe configurou a virtualização, em forma de estrela. Este tipo de configuração trouxe erros na navegação, por conta da detecção do chão como obstáculo. Para resolver tal problema, mudamos a configuração para uma série de linhas horizontais, considerando o ponto do Kinect como altura zero. Como estas linhas estão sempre posicionadas na mesma altura, o problema anterior foi eliminado. 

Entretanto, o consumo de CPU do \verb|ira_laser_tools|, é muito alto para o notebook utilizado, o que acabava tornando o processamento de dados muito lento e resultando em perda de informações do ambiente além de eventuais travas totais no sistema. Tivemos que retornar a antiga utilização de uma linha horizontal da \textit{Nuvem de Pontos}, como se fosse um scanner a laser, mas utilizando esta linha para o gmapping \ e o \verb|move_base|, garantindo sincronia entre localização e mapa de custo. Essa modificação melhorou a localização, tornando a detecção de obstáculos confiável e a integração entre o gmapping e o \verb|move_base| se tornou mais efetiva, viabilizando a utilização do gmapping.

Nesta etapa, a base para movimento angular do Kinect estava completa, então decidimos integrar a movimentação do Kinect para tentar obter um maior ângulo de visão. O Arduino já estava controlando a movimentação do servo-motor que rotacionava o Kinect, então criamos um nó do ROS que girava o motor de forma a fazer uma varredura do ambiente. A comunicação do Arduino dá como feedback o ângulo horizontal atual do servo-motor, valor necessário para configuração de uma transformada geométrica dinâmica da posição a partir da qual os dados do Kinect são obtidos. Infelizmente, os erros cumulativos desta abordagem se provaram muito grandes para que ela fosse útil, causando detecção de obstáculos onde os mesmos não existiam e prejudicando a funcionalidade do gmapping, fazendo com que o robô não conseguisse nem detectar objetos nem se localizar no ambiente.

Após algumas tentativas percebemos outro problema, que a equipe considerou mais impactante: o planejador de rotas local não estava seguindo uma rota condizente com a do planejador global. A rota planejada pelo planejador global era adequada, mas o local não a seguia, ignorando-a completamente. Como é o planejador local que controla o robô, a navegação autônoma não funcionava corretamente, colidindo em obstáculos e traçando rotas que não levariam o robô ao destino desejado se fossem completadas. Assim, decidimos fazer uma troca do planejador de rotas locais do padrão \verb|move_base| para o \verb|dwa_local_planner|, mais indicado para nosso robô como visto em \cite{dwaLocalPlanner}. Esta troca trouxe melhorias nas áreas citadas, trazendo rotas condizentes com o planejador global e que levavam ao local desejado. 
%Com as rotas adequadas, percebemos que as rotas traçadas ficavam muito perto era necessário ainda tínhamos problemas, pois o robô passava perto demais dos obstáculos ou batia nos que estavam fora de seu ângulo de visão, problema este que pode ser resolvido pela varredura, numa eventual continuidade do projeto.  

Nesta etapa, a equipe modificou alguns parâmetros com relação ao mapa de custo gerado. O mapa de custo é parte da navegação autônoma, sendo construído pelos sensores de maneira dinâmica neste caso. Ele é uma representação bidimensional do ambiente, sendo gerada uma matriz com valores de 0 a 255. Quando um sensor detecta um obstáculo, aquele ponto no mapa 2D é marcado com o valor 255 e custos em torno deste ponto são marcados com valores menores, decaindo de acordo com uma exponencial, até chegar ao raio determinado, onde o custo será 0. O parâmetro do raio é chamado \verb|inflation_radius| e a exponencial de decaimento é determinada utilizando o \verb|cost_scaling_factor|.  Mais informações podem ser encontradas em \cite{costmap2D}.

No pacote de visualização do ROS, o \verb|rviz|, podíamos ver que a rota traçada era agora condizente com os custos do mapa, mas que a área de alto custo em volta dos obstáculos era pequena em relação ao robô, o que fazia com que este passasse muito perto ou até colidisse com os obstáculos. Quando mudávamos o parâmetro \verb|inflation_radius|, que dá o raio de alto custo em volta dos obstáculos, não conseguíamos aumentar o tamanho dessa área. Descobrimos que para o funcionamento correto, deveríamos ter uma combinação adequada de \verb|inflation_radius| e \verb|cost_scaling_factor|. Feitas essas modificações, conduzimos novos testes, nos quais se verificou uma melhora significativa. Nessa fase, o robô é capaz de desviar os obstáculos presentes no mapa de custo global, traçar rotas globais e locais condizentes com os mapas de custo e atingir a maioria dos \textit{goals} com certa uma margem de erro aceitável. Infelizmente, durante esse processo, existe um certo erro no encaixe entre os mapas de custo local e global, que é corrigido pelo sistema de localização \verb|gmapping| em tempo, na maioria das vezes, aceitável. 

Fazendo uma revisão de todos os parâmetros da navegação, chegamos em alguns parâmetros que poderiam nos ajudar a fazer uma melhor localização usando do pacote gmapping. Esses parâmetros eram:

\begin{compactitem}
\item \verb|iterations|: Esse parâmetro seleciona o número de iterações que o gmapping fará para tentar encaixar os dois mapas. Antigamente era feita apenas uma iteração, agora são 5.
\item \verb|srr,str,stt e srt|: Esses quatro parâmetros dizem respeito a confiabilidade da odometria. Quando o gmapping vai fazer a transformação que corrige os erros da odometria, é essencial que ele saiba os erros máximos esperados, de forma a não chutar erros altos demais. Medimos esses erros em uma etapa anterior ao trabalho de oficinas 3, mas projetos com robôs parecidos indicavam valores muito menores aos que usávamos. Diminuímos todos esses parâmetros em cerca de dez vezes.
\item \verb|particles|: O gmapping é um sistema de localização baseado no método de monte carlo, e para achar a posição do robô no ambiente posiciona aleatóriamente várias partículas no ambiente, vendo qual delas é a mais próxima da posição real do robô. Mudamos esse parâmetro de 30 para 300, aumentando muito a precisão do pacote.
\end{compactitem}

A mudança desses três parâmetros deixou o robô com uma navegação muito perto da que esperávamos, sendo que o robô chegava em praticamente todos os destinos para o qual mandávamos. Percebemos que o único caso que ele não conseguia chegar ao destino era quando precisava dar ré, todos os outros casos de teste funcionaram. Procuramos mais um pouco dentre os parâmetros e vimos que o padrão para o \verb|dwa_local_planner| era que a velocidade linear mínima fosse de 0, ou seja, não deixava o robô andar de ré. Mudamos esse parâmetro e, após as modificações, obtivemos os resultados esperados: o robô conseguiu se movimentar com razoável precisão em todos os cenários que o testamos, com repetibilidade e sem cometer grandes erros.